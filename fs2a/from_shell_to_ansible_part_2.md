## Ansible
#### Вступление
Как указывается в предыдущей части работы, недостатки bash легко могут привести к тому, что

+ код оказывается запутанным и непригодным к рефакторингу;
+ выполнение кода зачастую может быть недетерминированным.

Обойти эти недостатки можно путём обучения персонала, введением жесткой производственной дисциплины и тщательным аудитом шелл-кода. Но этот путь является чрезвычайно ресурсоёмким (кроме того, встаёт вопрос о том, кто будет наздирать за надзирателем?). Рациональным является использование более формализованных инструментов для выполнения операций на серверах -- например, **ansible**. Помимо того, что ansible является специализированным инструментом для автоматизации и оркестрации, важной его особенностью является то, что код для выполнения множества элементарных действий ("скопировать файл", "создать файл из шаблона", "запустить сервис", "создать задачу cron" и т. д.) уже кем-то написан, проверен и помещен в некое подобие подключаемых библиотек, называемых "модулями". Эти модули вызываются строго определённым (и стандартизованным) образом, и в них уже реализованы необходимые проверки корректности операций, что позволяет сделать выполнение кода более предсказуемым и значительно уменьшает шанс что-либо сломать. Кроме того, код (несмотря на то, что ansible для описания требуемых действия использует синтаксис языка разметки YAML, порой получившиеся сценарии оказываются настолько сложными, что мы будем называть их "кодом", хотя это и не тот код, что в C или Python) за счёт значительно меньшей свободы самовыражения программиста получается значительно более читаемым и пригодным для правки.

На практике ansible имеет два основных применения:

+ оркестрация (выполнения заранее определённого набора операций на одном или нескольких узлах одновременно), в т.ч. развёртывание ПО (software provisioning) и приложений (application deployment);
+ создание и поддержание постоянной конфигурации ПО (SCM, software configuration management).

Следует понимать, что первый класс задач для ansible "родной", функциональный, а второй -- производный.
#### Playbooks
Плейбук (*playbook*) является сценарием для интерпретатора ansible, написанным на языке YAML. Состоит он, в основном, из объявления списка узлов (*hosts*), на которых будут выполнены задачи (*tasks*, "таски"), задания переменных (*vars*) и, собственно, самих задач. Пример:
```yaml
---
- name: CREATE FILE
  hosts: example.org

  variables:
    content: "MY CONTENT"

  tasks:
    - name: Create file with content
      copy:
        dest: /tmp/file
        content: >
          {{ content }}
...
```
Вместо секции `tasks` возможно указание расширения `roles`, но этот случай мы рассмотрим позже. Сейчас обратимся к случаю применения ansible как прямой замены bash.

Принципы, о которых следует знать перед написанием сценария ansible:

+ таски должны соблюдать принцип *идемпотентности*. Определение (из *педивикии*): "идемпоте́нтность (лат. *idem* — тот же самый + *potens* — способный) — свойство объекта или операции при повторном применении операции к объекту давать тот же результат, что и при первом." Применительно к ansible это означает, что изменение конфигурации должно происходить единоразово при первом выполнении сценария (плейбука) на определенном узле, при последующих выполнениях таск не должен выполнять действий без необходимости (если конфигурация не была изменена каким-либо третьим фактором);
+ данные должны быть отделены от кода. Все литералы типа путей, сетевых адресов и наименований надо выносить в переменные (`vars`; это, чаще всего, получаются константы, но в данном контексте смысл не меняется). Это, во-первых, сделает более прозрачным внесение правок в случае изменения условий, в которых применяется плейбук (например, запуск в другом окружении), и, во-вторых, имеющийся перед глазами полный набор данных упростит понимание назначения этого плейбука при его возможном изучении коллегами.

#### TODO: bash-to-ansible examples

#### Roles
При описании сложных конфигураций "плоские" плейбуки (даже с инклюдами) получаются слишком развесистыми и неудобными. Расширенным вариантом построения сценариев ansible являются *роли (roles)*. Условно (исходя из нашей практики применения) можно предположить, что плейбуки с tasks более удобны при оркестрации, а роли -- при описании постоянной конфигурации. Далее мы рассмотрим некоторые принципы построения ролей.

