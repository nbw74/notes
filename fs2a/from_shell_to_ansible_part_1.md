SCM: от shell к ansible
=======================
В данном обзоре мы рассмотрим использование Bash и Ansible для целей управления серверами.
## Вступление
Все ИТ-инженеры (называемые в народе "системными администраторами") в процессе своей жизнедеятельности на серверах неизбежно сталкиваются с вопросами автоматизации выполняемых задач. Те из них, кто работает с unix-like системами (в подавляющем большинстве случаев это GNU/Linux в deb-based или rpm-based инкарнациях), чаще всего начинают решение таковых задач с написания сценариев пакетного выполнения команд, т.е. *шелл-скриптов* (от "shell", командная оболочка), в качестве языка чаще всего используя командный интерпретатор *sh* или *bash*.
### Bash
#### Преимущества bash
+ Низкий порог вхождения. Любой индивидуум с массой мозга чуть больше, чем у ежа, с лёгкостью может его освоить. Ну, или думать, что освоил.
+ Синтаксическая свобода. Есть много способов реализовать задуманный алгоритм.
+ Универсальность. Шелл-сценарий будет работать везде, куда только сможет положить его админ, ничего энтерпрайзнее убунтосервера не видевший.
+ Гибкость и мощь. Затратив время *t* на шелле можно написать всё. Ну, или почти всё.
#### Недостатки bash
+ Низкий порог вхождения. В частности, поэтому 95% существующего в мире шелл-кода представляет собой чудовищное говно.
+ Синтаксическая свобода. Необязательно даже объявлять переменные. Их и не объявляют, в результате чего скрипты подкладывают подлянку в самый неподходящий момент.

Примеров того, как писать не надо, я приводить не буду. Все их и так видели много раз, и даже сами писали. Подробнее остановимся на том, как писать надо.
## Цель
    Получить код:
- читаемый тем, кто его написал (даже через 2 года работы в службе ассенизации);
  - и теми, кому впоследствии придётся этот код править;
- работающий так, как задумано при написании;
- имеющий средства обработки ошибок написания и выполнения.
## Средства
Пишем на bash. Эфемерное требование совместимости с кондовым Bourne shell (sh) на практике неактуально уже очень давно -- в большинстве дистрибутивов `sh` является символьной ссылкой на `bash`.
#### Используем функции
Для структурирования кода удобнее всего использовать *функции* (function). В начале объявляется функция *main*, которая вызывающается в самом конце скрипта, и содержит в себе вызовы других функций. Каждая функция делает что-то одно (но хорошо, да).
```sh
#!/bin/bash

main() {
    _echo
}

_echo() {
    echo 'To bee or not to bee?'
)

main
```
#### Объявляем переменные
Всегда объявляем переменные перед использованием (с указанием типа -- *integer, array*). Константы обозначаем явно как `readonly`. Внутри функций используем локальные переменные. Чтобы не забывать об этом -- передаём башу ключик *nounset*:
```sh
#!/bin/bash

set -o nounset

readonly TITLE="Current UNIX epoch is"

main() {
    local -i unix_date=0

    get_date
    printf '%s\n' "${TITLE}: $unix_date"

    # Fail
    rm -rf /tmp/$UNDEF
}

get_date() {
    unix_date=$(date '+%s')
}

main
```
```sh
~% ./test.sh
Current UNIX epoch is: 1562833704
./test.sh: line 14: UNDEF: unbound variable
```
#### Обрабатываем ошибки
При возникновении ошибки в процессе выполнения скрипта он не должен падать как попало (и, тем более, неконтролируемо продолжать выполнение). Вместо этого должна вызываться специально оформленная функция. В примере также используется перенаправление **stderr** в файл, парсинг аргументов (GNU-style) и обработка выхода:
```sh
#!/bin/bash

set -o nounset
set -o errtrace
set -o pipefail

readonly LOGERR=$(mktemp --tmpdir "${bn%\.*}.XXXX")
typeset -i DEBUG=0

main() {
    local fn=${FUNCNAME[0]}

    trap 'except $LINENO' ERR
    trap _exit EXIT

    if (( ! DEBUG )); then
	exec 4>&2
	exec 2>>"$LOGERR"
    fi

    echo "Error occured" >&2
    false
}

except() {
    local ret=$?
    local no=${1:-no_line}

    if [[ -t 1 ]]; then
	echo "* FATAL: error occured in function '$fn' near line ${no}. Stderr: '$(awk '$1=$1' ORS=' ' "${LOGERR}")'"
    fi

    logger -p user.err -t "$bn" "* FATAL: error occured in function '$fn' near line ${no}. Stderr: '$(awk '$1=$1' ORS=' ' "${LOGERR}")'"
    exit $ret
}

_exit()
    local ret=$?

    if (( ! DEBUG )); then
	exec 2>&4 4>&-
    fi

    [[ -f $LOGERR ]] && rm "$LOGERR"

    exit $ret
}

getopt -T; (( $? == 4 )) || { echo "incompatible getopt version" >&2; exit 4; }

if ! TEMP=$(getopt -o d --longoptions debug -n "$bn" -- "$@")
then
    echo "Terminating..." >&2
    exit 1
fi

eval set -- "$TEMP"
unset TEMP

while true; do
    case $1 in
	-d|--debug)	DEBUG=1;    shift   ;;
	*)		exit 1
    esac
done

main
```
#### Проверяем синтаксис
Правильному написанию шелл-скриптов весьма способствует автоматическая проверка синтаксиса утилитой `shellcheck`
```sh
~% cat test.sh
#!/bin/bash

main() {
    local file=$1

    [ -f /tmp/$file ] && rm /tmp/$file
}

main "$@"

~% shellcheck ./test.sh

In ./test.sh line 6:
    [ -f /tmp/$file ] && rm /tmp/$file
              ^---^ SC2086: Double quote to prevent globbing and word splitting.
                                 ^---^ SC2086: Double quote to prevent globbing and word splitting.

For more information:
  https://www.shellcheck.net/wiki/SC2086 -- Double quote to prevent globbing ...
```
